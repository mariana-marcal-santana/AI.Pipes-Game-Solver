Pela ordem dos tópicos do enunciado:
1 - Breve descrição do problema (regras e objetivo): 
2 - Descrição da ideia geral para abordar o problema:

Vamos apresentar o relatorio para o projeto de inteligencia artificial do nosso grupo, al 25.
Como podemos ver na apresentaçao o input do programa é uma grelha quadrada, com peças rotativas, em que o
objetivo é conectar todas as peças sem fugas como na se vê na imagem de output.
No contexto do projeto, este é um problema de procura que, tal como o nome indica procura a solução única da grelha em questão.

A nossa resolução consiste na leitura e processamento com inferências da grelha de jogo, seguido por uma procura em 
profundidade pela solução do problema. 
Para verificarmos se a solução foi encontrada usamos na funçao goal_test uma verificação com DFS para
aferir se existe apenas um componente fortemente ligado na grelha, ou seja, se todas as peças estão bem conectadas. 
Para as funções actions e result, adotamos soluções que minimizam o runtime do projeto, e que vamos passar a descrever.

!!!!!!!!!!!!!!!!!!!!!!!!

3 - Identificação do que é uma ação no contexto do problema:
No contexto do problema uma ação consiste em fixar a orientação de uma determinada peça da grelha.

A função "actions" retorna uma lista de ações possíveis para o Board sobre o qual atua e 
em cada nível de profundidade da árvore de procura que está a ser gerada podemos apenas reorientar a peça correspondente à mesma por exemplo:
para uma profundidade 0 estamos apenas a rodar a peça (0,0) e para profundidade 1, a peça (0,1), etc
A função gera para a peça, uma lista de ações possíveis e compatíveis com as peças adjacentes à que estamos a analisar. 
Gerando apenas ações compatíveis minimizamos o número de Nodes a criar e visitar, o que torna a implementação mais eficiente.

!!!!!!!!!!!!!!!!!!!!!!!!

4 - Descrição do que é o resultado de aplicar uma ação num estado:
O resultado de aplicar uma ação num estado é um novo estado do problema em que o seu Board contém a peça na posição passada como
argumento na orientação passada em argumento. Além disso, com vista a melhorar a eficiência da solução, repete-se a pesquisa por 
novas inferências em relação às peças do tabuleiro que se encontram nas posições seguintes à da peça que foi fixada.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

5 - Caso exista algum tipo de pre-processamento ou métodos de inferência, estes devem ser mencionados:

Da mesma maneira que procuramos inferências sobre cada Board depois de cada peça ser fixada, 
no ínicio do problema tiramos também conclusões sobre as peças da grelha de input. 
Para inferirmos sobre cada peça geramos 4 listas (respetivas a cada lado da peça) com as orientações possíveis 
e compatíveis com as peças já fixadas. 

Seguidamente, intersetamos-las para obter as orientações compatíveis com todos os lados e se houver apenas
uma posição possível, orientamos a peça em questão para essa posição e marcamos-la como correta.
Na primeira ronda de inferências, que é executada logo após a leitura da grelha, realizam-se inferencias para todo o board,
o que difere das vezes que é chamada na funçao result em que apenas se infere para peças de posições posteriores à da peça que 
foi fixada.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

6 - Pequena avaliação experimental comparando diferentes procuras com as instâncias disponibilizadas:
Antes de termos a solução com uma DFS na funçao goal_test, experimentamos com uma versão desta funçao que analisava o board e procurava
fugas ou inconsistências no mesmo. A primeira heuristica que testamos com esta funçao, que aparece entitulada como Leaks, contava
o numero de fugas do board para que a procura priorizasse boards com menos fugas. A segunda heuristica que testamos, que aparece
como depth marcava a posiçao da primeira peça com fugas do board e assumia que seria mais vantajoso explorar nodes que tivessem
uma fuga mais tarde na analise.
Para a avaliação experimental realizamos procuras com DFS, BFS, Greedy e A* searchs e registamos os tempos na tabela.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

7 - Identificação da procura final selecionada, quais as suas características (heurística, por exemplo), e motivo da escolha:
Acabamos por escolher a depth first tree search porque foi a que obteve os melhores tempos com a nossa implementação.